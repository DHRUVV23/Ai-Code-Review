package worker

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"

	"github.com/hibiken/asynq"
	
	// Import your services
	"github.com/DHRUVV23/ai-code-review/backend/internal/service"
)

// ReviewIssue represents the JSON structure returned by Gemini
type ReviewIssue struct {
	File       string `json:"file"`
	Line       int    `json:"line"`
	Type       string `json:"type"`
	Severity   string `json:"severity"`
	Message    string `json:"message"`
	Suggestion string `json:"suggestion"`
}

// HandleReviewTask is the logic that runs when a job is picked up
func HandleReviewTask(ctx context.Context, t *asynq.Task) error {
	// 1. Unmarshal the Payload (Defined in tasks.go)
	var payload ReviewPayload
	if err := json.Unmarshal(t.Payload(), &payload); err != nil {
		return fmt.Errorf("json.Unmarshal failed: %v: %w", err, asynq.SkipRetry)
	}

	log.Printf("ğŸ¤– Processing Review for: %s/%s PR #%d", payload.RepoOwner, payload.RepoName, payload.PRNumber)

	// 2. Initialize Services
	ghService := service.NewGitHubService()
	aiService := service.NewAIService()

	// 3. Get the Code Diff from GitHub
	diff, err := ghService.GetPullRequestDiff(ctx, payload.RepoOwner, payload.RepoName, payload.PRNumber)
	if err != nil {
		log.Printf("âŒ Failed to get diff: %v", err)
		return err // Retry later
	}

	if diff == "" {
		log.Println("âš ï¸ Diff is empty, skipping review.")
		return nil
	}

	// 4. Send to Gemini AI
	reviewJSON, err := aiService.ReviewCode(ctx, diff, "concise")
	if err != nil {
		log.Printf("âŒ AI Analysis failed: %v", err)
		return err // Retry later
	}

	// 5. Format the JSON into a Pretty Markdown Table
	formattedComment := formatReviewToMarkdown(reviewJSON)
	
	// 6. Post the Comment to GitHub
	if err := ghService.PostComment(ctx, payload.RepoOwner, payload.RepoName, payload.PRNumber, formattedComment); err != nil {
		log.Printf("âŒ Failed to post comment: %v", err)
		return err
	}

	log.Printf("âœ… Review Posted for PR #%d!", payload.PRNumber)
	return nil
}

// Helper Function: Converts JSON string -> Markdown Table
func formatReviewToMarkdown(rawJSON string) string {
	// Clean up the string (Gemini sometimes wraps output in ```json ... ```)
	cleanJSON := strings.TrimSpace(rawJSON)
	cleanJSON = strings.TrimPrefix(cleanJSON, "```json")
	cleanJSON = strings.TrimPrefix(cleanJSON, "```")
	cleanJSON = strings.TrimSuffix(cleanJSON, "```")

	var issues []ReviewIssue
	if err := json.Unmarshal([]byte(cleanJSON), &issues); err != nil {
		// If parsing fails, fallback to displaying the raw text/JSON
		return fmt.Sprintf("## ğŸ¤– AI Review\n\n%s", rawJSON)
	}

	if len(issues) == 0 {
		return "## ğŸ¤– AI Code Review\n\nğŸš€ **LGTM! (Looks Good To Me)**\n\nNo critical issues found. Great job!"
	}

	// Build the Markdown Table
	var sb strings.Builder
	sb.WriteString("## ğŸ¤– AI Code Review\n\n")
	sb.WriteString("| ğŸŸ¢ Severity | ğŸ“‚ File | ğŸ“ Line | âš ï¸ Issue | ğŸ’¡ Suggestion |\n")
	sb.WriteString("| :--- | :--- | :--- | :--- | :--- |\n")

	for _, issue := range issues {
		// Add an emoji based on severity
		severityIcon := "âšª"
		switch strings.ToLower(issue.Severity) {
		case "high":
			severityIcon = "ğŸ”´"
		case "medium":
			severityIcon = "ğŸŸ "
		case "low":
			severityIcon = "ğŸŸ¢"
		}

		// Format the row
		row := fmt.Sprintf("| %s **%s** | `%s` | %d | **%s**: %s | %s |\n",
			severityIcon, issue.Severity, issue.File, issue.Line, issue.Type, issue.Message, issue.Suggestion)
		sb.WriteString(row)
	}

	sb.WriteString("\n\n---\n*generated by AI Code Reviewer*")
	return sb.String()
}

// StartWorker initializes the background processor
func StartWorker(redisAddr string) {
	srv := asynq.NewServer(
		asynq.RedisClientOpt{Addr: redisAddr},
		asynq.Config{
			Concurrency: 10, // Process 10 reviews at once
		},
	)

	mux := asynq.NewServeMux()
	// Map the "review:pr" string to our handler function
	mux.HandleFunc(TypeReviewPR, HandleReviewTask)

	// Run in a Goroutine so it doesn't block the API Server
	go func() {
		log.Println("ğŸ‘· Worker Server Started...")
		if err := srv.Run(mux); err != nil {
			log.Fatalf("âŒ Worker failed to start: %v", err)
		}
	}()
}