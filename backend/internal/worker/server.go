package worker

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"strings"

	"github.com/hibiken/asynq"
	
	"github.com/DHRUVV23/ai-code-review/backend/internal/service"
)


type ReviewIssue struct {
	File       string `json:"file"`
	Line       int    `json:"line"`
	Type       string `json:"type"`
	Severity   string `json:"severity"`
	Message    string `json:"message"`
	Suggestion string `json:"suggestion"`
}

func HandleReviewTask(ctx context.Context, t *asynq.Task) error {

	var payload ReviewPayload
	if err := json.Unmarshal(t.Payload(), &payload); err != nil {
		return fmt.Errorf("json.Unmarshal failed: %v: %w", err, asynq.SkipRetry)
	}

	log.Printf("ü§ñ Processing Review for: %s/%s PR #%d", payload.RepoOwner, payload.RepoName, payload.PRNumber)


	ghService := service.NewGitHubService()
	aiService := service.NewAIService()


	diff, err := ghService.GetPullRequestDiff(ctx, payload.RepoOwner, payload.RepoName, payload.PRNumber)
	if err != nil {
		log.Printf(" Failed to get diff: %v", err)
		return err 
	}

	if diff == "" {
		log.Println(" Diff is empty, skipping review.")
		return nil
	}


	reviewJSON, err := aiService.ReviewCode(ctx, diff, "concise")
	if err != nil {
		log.Printf(" AI Analysis failed: %v", err)
		return err
	}

	formattedComment := formatReviewToMarkdown(reviewJSON)
	
	if err := ghService.PostComment(ctx, payload.RepoOwner, payload.RepoName, payload.PRNumber, formattedComment); err != nil {
		log.Printf(" Failed to post comment: %v", err)
		return err
	}

	log.Printf("Review Posted for PR #%d!", payload.PRNumber)
	return nil
}


func formatReviewToMarkdown(rawJSON string) string {
	cleanJSON := strings.TrimSpace(rawJSON)
	cleanJSON = strings.TrimPrefix(cleanJSON, "```json")
	cleanJSON = strings.TrimPrefix(cleanJSON, "```")
	cleanJSON = strings.TrimSuffix(cleanJSON, "```")

	var issues []ReviewIssue
	if err := json.Unmarshal([]byte(cleanJSON), &issues); err != nil {
		// If parsing fails, fallback to displaying the raw text/JSON
		return fmt.Sprintf("## ü§ñ AI Review\n\n%s", rawJSON)
	}

	if len(issues) == 0 {
		return "##  AI Code Review\n\n **LGTM! (Looks Good To Me)**\n\nNo critical issues found. Great job!"
	}

	var sb strings.Builder
	sb.WriteString("## ü§ñ AI Code Review\n\n")
	sb.WriteString("| üü¢ Severity | üìÇ File | üìù Line | ‚ö†Ô∏è Issue | üí° Suggestion |\n")
	sb.WriteString("| :--- | :--- | :--- | :--- | :--- |\n")

	for _, issue := range issues {
		
		severityIcon := "‚ö™"
		switch strings.ToLower(issue.Severity) {
		case "high":
			severityIcon = "üî¥"
		case "medium":
			severityIcon = "üü†"
		case "low":
			severityIcon = "üü¢"
		}

		
		row := fmt.Sprintf("| %s **%s** | `%s` | %d | **%s**: %s | %s |\n",
			severityIcon, issue.Severity, issue.File, issue.Line, issue.Type, issue.Message, issue.Suggestion)
		sb.WriteString(row)
	}

	sb.WriteString("\n\n---\n*generated by AI Code Reviewer*")
	return sb.String()
}

func StartWorker(redisAddr string) {
	srv := asynq.NewServer(
		asynq.RedisClientOpt{Addr: redisAddr},
		asynq.Config{
			Concurrency: 10, 
		},
	)

	mux := asynq.NewServeMux()
	
	mux.HandleFunc(TypeReviewPR, HandleReviewTask)

	
	go func() {
		log.Println("üë∑ Worker Server Started...")
		if err := srv.Run(mux); err != nil {
			log.Fatalf(" Worker failed to start: %v", err)
		}
	}()
}